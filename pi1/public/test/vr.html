<!DOCTYPE html>
<html>

<head>
    <title>VR</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
    <script src="../webrtc.js"></script>
    <script>

        var leftDeviceId = 'f8c4fa38ce2a02a43a0763a6f8158229880117ebd7b33c55895b08d68bcdaa9a';
        var rightDeviceId = '0613fe2bd87326a5429086d28654ab9f5708d584596dfc1f837c4e6b48494fd5';

        WebRTC.addEventListener('remotedevicelist', function(event) {
            var socketid = event.detail.socketid;
            var videoDevices = event.detail.videoDevices;
            videoDevices.forEach(function(videoDevice) {
                if (videoDevice.deviceId === leftDeviceId || videoDevice.deviceId === rightDeviceId) {
                    WebRTC.connect(socketid, videoDevice.deviceId);
                }
            });
        });

        var isright = true;
        WebRTC.addEventListener('remotestream', function(event) {
            console.log(event);
            var stream = event.detail;
            if (!isright) { // Hack, der davon ausgeht, dass der linke stream zuerst kommt
                var videoleft = document.getElementById('videoleft');
                videoleft.srcObject = stream;
            } else {
                var videoright = document.getElementById('videoright');
                videoright.srcObject = stream;
                isright = false;
            }
        });

    </script>
    <script src="../three.min.js"></script>
    <script src="../WebVR.js"></script>
    <script>
        window.addEventListener('load', function () {
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 2000);
            camera.layers.enable(1); // render left view when no stereo available

            // video
            var videoleft = document.getElementById('videoleft');
            videoleft.play();
            var textureleft = new THREE.Texture(videoleft);
            textureleft.generateMipmaps = false;
            textureleft.minFilter = THREE.NearestFilter;
            textureleft.magFilter = THREE.NearestFilter;
            textureleft.format = THREE.RGBFormat;
            textureleft.offset.set( 0, 0 );
            textureleft.repeat.set( 2, 1 );
            var videoright = document.getElementById('videoright');
            videoright.play();
            var textureright = new THREE.Texture(videoright);
            textureright.generateMipmaps = false;
            textureright.minFilter = THREE.NearestFilter;
            textureright.magFilter = THREE.NearestFilter;
            textureright.format = THREE.RGBFormat;
            textureright.offset.set( 0, 0 );
            textureright.repeat.set( 2, 1 );
            setInterval(function () {
                if (videoleft.readyState >= videoleft.HAVE_CURRENT_DATA) {
                    textureleft.needsUpdate = true;
                }
                if (videoright.readyState >= videoright.HAVE_CURRENT_DATA) {
                    textureright.needsUpdate = true;
                }
            }, 1000 / 24);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101010);
            // left
            var geometry = new THREE.SphereBufferGeometry(500, 60, 40);
            // invert the geometry on the x-axis so that all of the faces point inward
            geometry.scale(- 1, 1, 1);
            var uvs = geometry.attributes.uv.array;
            for (var i = 0; i < uvs.length; i += 2) {
                uvs[i] *= 0.5;
            }
            var material = new THREE.MeshBasicMaterial({ map: textureleft });
            var mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.y = - Math.PI / 2;
            mesh.layers.set(1); // display in left eye only
            scene.add(mesh);

            // right
            var geometry = new THREE.SphereBufferGeometry(500, 60, 40);
            // invert the geometry on the x-axis so that all of the faces point inward
            geometry.scale(- 1, 1, 1);
            var uvs = geometry.attributes.uv.array;
            for (var i = 0; i < uvs.length; i += 2) {
                uvs[i] *= 0.5;
            }
            var material = new THREE.MeshBasicMaterial({ map: textureright });
            var mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.y = - Math.PI / 2;
            mesh.layers.set(2); // display in right eye only
            scene.add(mesh);


            var renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.vr.enabled = true;
            document.body.appendChild(renderer.domElement);
            document.body.appendChild( WEBVR.createButton( renderer, { referenceSpaceType: 'local' } ) );

            window.addEventListener( 'resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );                
            }, false );

            renderer.setAnimationLoop(function() {
                renderer.render( scene, camera );
            });

        });
    </script>
</head>

<body>
    <!--
    <video id="video" loop muted crossOrigin="anonymous" webkit-playsinline style="display:none">
        <source src="https://threejs.org/examples/textures/MaryOculus.webm">
        <source src="https://threejs.org/examples/textures/MaryOculus.mp4">
    </video>
    -->
    <video id="videoleft" autoplay="autoplay" style="display:none"></video>
    <video id="videoright" autoplay="autoplay" style="display:none"></video>
</body>

</html>